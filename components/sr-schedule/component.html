<link rel="import" href="../../bower_components/polymer/polymer.html" />

<polymer-element name="sr-schedule">
    <template>
        <style>
            :host {
                display: block;
                font-size: 1.6em;
                text-align: center;
            }

            table {

            }

            td, th {
                padding: 0.25em 0.5em;
            }

            tr.old {
                opacity: 0.5;
                font-size: 1.2em;
            }

            tr.current {
                font-weight: bold;
                font-size: 1.5em;
            }

            tr.next {
                opacity: 0.8;
                font-size: 1.3em;
            }

            tr td:nth-of-type(4n+3) {
                padding-left: 1em;
            }

            tr td:nth-of-type(4n+6) {
                padding-right: 1em;
            }
        </style>

        <table>
            <tr>
                <th></th>
                <th></th>
                <template repeat="{{ arena in arenas }}">
                    <th colspan="4">{{ arena }}</th>
                </template>
            </tr>

            <template repeat="{{ match in schedule }}">
                <tr class="{{ match | formatMatchClass }}">
                    <td>{{ match.num }}</td>
                    <td><time datetime="{{ match.gameStart }}"></time></td>
                    <template repeat="{{ arena in arenas }}">
                        <template repeat="{{ corner in [0, 1, 2, 3] }}">
                            <td>
                                <span style="color: {{ corners[corner].colour }}">
                                    {{ match.arenas[arena].teams[corner] || 'â€”' }}
                                </span>
                            </td>
                        </template>
                    </template>
                </tr>
            </template>
        </table>
    </template>

    <script src="../../bower_components/moment/moment.js"></script>

    <script>
        Polymer({
            comp: null,
            arenas: undefined,
            corners: undefined,
            schedule: {},
            ready: function() {
                setInterval(this._updateDisplayedTimes.bind(this), 5000);
            },
            _updateDisplayedTimes: function() {
                var dates = this.shadowRoot.querySelectorAll('time');
                dates.array().forEach(function(elem) {
                    var epoch = moment(elem.getAttribute('datetime'));
                    elem.textContent = epoch.fromNow();
                });
            },
            compChanged: function() {
                this.comp.api.getArenas(function(arenas) {
                    this.arenas = Object.keys(arenas);
                    this.updateSchedule();
                }.bind(this));

                this.comp.api.getCorners(function(corners) {
                    this.corners = corners;
                    this.updateSchedule();
                }.bind(this));

                this.comp.stream.addEventListener('match', function(e) {
                    this.updateSchedule();
                }.bind(this));

                this.comp.stream.addEventListener('knockouts', function() {
                    this.updateSchedule();
                }.bind(this));
            },
            updateSchedule: function() {
                if (this.arenas == null || this.corners == null) {
                    return;  // wait until they're set
                }

                var receiveMatchList = function(matches) {
                    var schedule = {};
                    var startTimes = {};
                    var endTimes = {};
                    var gameStartTimes = {};

                    matches.forEach(function(match) {
                        if (!schedule[match.num]) {
                            schedule[match.num] = {};
                        }

                        schedule[match.num][match.arena] = match;
                        startTimes[match.num] = match.times.period.start;
                        endTimes[match.num] = match.times.period.end;
                        gameStartTimes[match.num] = match.times.game.start;
                    }.bind(this));

                    var formattedSchedule = [];
                    for (var matchNumber in schedule) {
                        formattedSchedule.push({num: matchNumber,
                                                arenas: schedule[matchNumber],
                                                start: startTimes[matchNumber],
                                                end: endTimes[matchNumber],
                                                gameStart: gameStartTimes[matchNumber]})
                    }

                    // shrink the schedule to the matches around the current match
                    var now = new Date();
                    var currentIndex = 0;
                    formattedSchedule.forEach(function(match, ix) {
                        if (moment(match.start) < now) {
                            currentIndex = ix;
                        }
                    });
                    var firstMatchIx = currentIndex - 2;
                    if (firstMatchIx < 0) {
                        firstMatchIx = 0;
                    }
                    var lastMatchIx = currentIndex + 10;
                    if (lastMatchIx > formattedSchedule.length) {
                        lastMatchIx = formattedSchedule.length;
                    }

                    this.schedule = formattedSchedule.slice(firstMatchIx, lastMatchIx);
                    this.async(this._updateDisplayedTimes);
                }.bind(this);

                this.comp.api.getMatches(receiveMatchList);
            },
            formatMatchClass: function(match) {
                if (moment(match.end) < new Date()) {
                    return 'old';
                } else if (moment(match.start) > new Date()) {
                    return 'next';
                } else {
                    return 'current';
                }
            }
        });
    </script>
</polymer-element>
